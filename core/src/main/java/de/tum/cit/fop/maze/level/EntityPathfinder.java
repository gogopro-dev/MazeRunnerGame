package de.tum.cit.fop.maze.level;import com.badlogic.gdx.physics.box2d.*;import de.tum.cit.fop.maze.essentials.AbsolutePoint;import de.tum.cit.fop.maze.BodyBits;import de.tum.cit.fop.maze.entities.Entity;import de.tum.cit.fop.maze.Globals;import de.tum.cit.fop.maze.essentials.BoundingRectangle;import java.util.*;/** * This class is used to find the path for the enemy to follow. It uses the A* algorithm to find the path. * It creates a matrix of obstacles based on the world with increased precision, so that the movement of the enemy is * smooth and precise. */public class EntityPathfinder {    /**     * Represents a point relative to the starting point.     *     * @param x The x offset.     * @param y The y offset.     */    private record RelativePoint(float x, float y) {        @Override        public boolean equals(Object obj) {            if (obj == null) {                return false;            }            if (obj == this) {                return true;            }            if (obj instanceof RelativePoint other) {                return x == other.x && y == other.y;            }            return false;        }        @Override        public int hashCode() {            return Objects.hash(x, y);        }    }    ///  Support fractional directions    private final RelativePoint[] directions = {        new RelativePoint(0, 1),        new RelativePoint(1, 0),        new RelativePoint(0, -1),        new RelativePoint(-1, 0),        new RelativePoint(1, 1),        new RelativePoint(1, -1),        new RelativePoint(-1, 1),        new RelativePoint(-1, -1)    };    private final int precision = 2;    private final float unitMeters;    public EntityPathfinder() {        this.unitMeters = Globals.CELL_SIZE_METERS / precision;    }    /**     * Heuristic function to estimate the cost of getting from point a to point b.     *     * @param a The starting point.     * @param b The ending point.     * @return The estimated cost.     */    private float heuristic(AbsolutePoint a, AbsolutePoint b) {        return a.distance(b);    }    private boolean canMoveToPoint(Body body, BoundingRectangle rectange, AbsolutePoint point) {        boolean[] result = {true};        float x0 = point.x() - rectange.width() / 2;        float y0 = point.y() - rectange.height() / 2;        float x1 = point.x() + rectange.width() / 2;        float y1 = point.y() + rectange.height() / 2;        LevelScreen.getInstance().worldLock.lock();        body.getWorld().QueryAABB(fixture -> {                if (fixture.getFilterData().categoryBits == BodyBits.WALL) {                    result[0] = false;                }                return true;            }, x0, y0, x1, y1        );        LevelScreen.getInstance().worldLock.unlock();        return result[0];    }    /**     * Finds the path from start to end using the A* algorithm. (With Priority Queue)     * The assumed movement is in all 8 directions. (meaning diagonal movement is allowed)     * Diagonal movement is allowed, but accounted for, meaning the cost of diagonal movement is sqrt(2).     *     * @param entity The entity from which to look.     * @param end    The ending point.     * @return The list of points representing the path.     */    List<AbsolutePoint> aStar(Entity entity, AbsolutePoint end) {        AbsolutePoint start = new AbsolutePoint(            entity.getBody().getPosition().x, entity.getBody().getPosition().y        );        float cellDistanceMax = Globals.ENTITY_PATHFINDING_RANGE;        float distanceLimit = unitMeters * precision * cellDistanceMax;        if (heuristic(start, end) > distanceLimit) {            return null;        }        if (start.distance(end) <= unitMeters * 1.1f) {            return List.of(end);        }        PriorityQueue<RelativePoint> open = new PriorityQueue<>(            Comparator.comparingDouble(                p -> heuristic(new AbsolutePoint(p.x + start.x(), p.y + start.y()), end)            )        );        HashMap<RelativePoint, RelativePoint> cameFrom = new HashMap<>();        HashMap<RelativePoint, Float> cost = new HashMap<>();        open.add(new RelativePoint(0, 0));        cost.put(new RelativePoint(0, 0), 0f);        while (!open.isEmpty()) {            RelativePoint current = open.poll();            AbsolutePoint currentPoint = new AbsolutePoint(                start.x() + current.x * unitMeters, start.y() + current.y * unitMeters            );            if (currentPoint.distance(end) <= unitMeters * 1.5f) {                LinkedList<AbsolutePoint> path = new LinkedList<>();                path.addFirst(end);                while (cameFrom.containsKey(current)) {                    current = cameFrom.get(current);                    path.addFirst(                        new AbsolutePoint(start.x() + current.x * unitMeters, start.y() + current.y * unitMeters)                    );                }                path.remove(0);                return path;            }            for (RelativePoint point : directions) {                RelativePoint neighbor = new RelativePoint(current.x + point.x, current.y + point.y);                AbsolutePoint neighborPoint = new AbsolutePoint(                    start.x() + neighbor.x * unitMeters, start.y() + neighbor.y * unitMeters                );                if (neighborPoint.distance(start) > distanceLimit) {                    continue;                }                if (!canMoveToPoint(entity.getBody(), entity.boundingRectangle, neighborPoint)) continue;                float newCost = cost.get(current) + heuristic(currentPoint, neighborPoint);                if (!cost.containsKey(neighbor) || newCost < cost.get(neighbor)) {                    cost.put(neighbor, newCost);                    cameFrom.put(neighbor, current);                    open.add(neighbor);                }            }        }        return null;    }}