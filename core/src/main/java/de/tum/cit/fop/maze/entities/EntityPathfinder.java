package de.tum.cit.fop.maze.entities;import com.badlogic.gdx.physics.box2d.*;import de.tum.cit.fop.maze.essentials.BodyBits;import de.tum.cit.fop.maze.essentials.AbsolutePoint;import de.tum.cit.fop.maze.essentials.Globals;import de.tum.cit.fop.maze.essentials.BoundingRectangle;import de.tum.cit.fop.maze.level.LevelScreen;import java.util.*;/** * This class is used to find the path for the enemy to follow. It uses the A* algorithm to find the path. * It creates a matrix of obstacles based on the world with increased precision, so that the movement of the enemy is * smooth and precise. */public class EntityPathfinder {    /**     * Represents a point relative to the starting point.     *     * @param x The x offset.     * @param y The y offset.     */    private record RelativePoint(float x, float y) {        @Override        public boolean equals(Object obj) {            if (obj == null) {                return false;            }            if (obj == this) {                return true;            }            if (obj instanceof RelativePoint other) {                return x == other.x && y == other.y;            }            return false;        }        @Override        public int hashCode() {            return Objects.hash(x, y);        }        public AbsolutePoint toAbsolutePoint(AbsolutePoint origin, float unitMeters) {            return new AbsolutePoint(origin.x() + this.x * unitMeters, origin.y() + this.y * unitMeters);        }    }    ///  Support fractional directions    private final RelativePoint[] directions = {        new RelativePoint(0, 1),        new RelativePoint(1, 0),        new RelativePoint(0, -1),        new RelativePoint(-1, 0),        new RelativePoint(1, 1),        new RelativePoint(1, -1),        new RelativePoint(-1, 1),        new RelativePoint(-1, -1)    };    private final int precision = 2;    private final float unitMeters;    public EntityPathfinder() {        this.unitMeters = Globals.CELL_SIZE_METERS / precision;    }    /**     * Heuristic function to estimate the cost of getting from point a to point b.     *     * @param a The starting point.     * @param b The ending point.     * @return The estimated cost.     */    private float heuristic(AbsolutePoint a, AbsolutePoint b) {        return a.distance(b);    }    /**     * Thread-safe method to query Box2D     * It check whether the entity can move to the given point.     *     * @param body     The body of the entity.     * @param rectange The bounding rectangle of the entity.     * @param point    The point to move to.     * @return {@code true} if the entity can move to the point, {@code false} otherwise.     */    private boolean canMoveToPoint(Body body, BoundingRectangle rectange, AbsolutePoint point) {        boolean[] result = {true};        float x0 = point.x() - rectange.width() / 2;        float y0 = point.y() - rectange.height() / 2;        float x1 = point.x() + rectange.width() / 2;        float y1 = point.y() + rectange.height() / 2;        LevelScreen.getInstance().worldLock.lock();        body.getWorld().QueryAABB(fixture -> {            if (fixture.getFilterData().categoryBits == BodyBits.WALL ||                fixture.getFilterData().categoryBits == BodyBits.WALL_TRANSPARENT) {                    result[0] = false;                return false;                }                return true;            }, x0, y0, x1, y1        );        LevelScreen.getInstance().worldLock.unlock();        return result[0];    }    /**     * Finds the path from start to end using the A* algorithm. (With Priority Queue)     * The assumed movement is in all 8 directions. (meaning diagonal movement is allowed)     * Diagonal movement is allowed, but accounted for, meaning the cost of diagonal movement is sqrt(2).     *     * @param entity The entity from which to look.     * @param end    The ending point.     * @return The list of points representing the path.     */    public List<AbsolutePoint> aStar(Entity entity, AbsolutePoint end) {        AbsolutePoint start = entity.getPosition();        float cellDistanceMax = Globals.ENTITY_PATHFINDING_RANGE;        float distanceLimit = unitMeters * precision * cellDistanceMax;        if (heuristic(start, end) > distanceLimit) {            return null;        }        if (start.distance(end) <= unitMeters * 1.1f) {            return List.of(end);        }        PriorityQueue<RelativePoint> open = new PriorityQueue<>(            Comparator.comparingDouble(                p -> heuristic(p.toAbsolutePoint(start, unitMeters), end)            )        );        HashMap<RelativePoint, RelativePoint> cameFrom = new HashMap<>();        HashMap<RelativePoint, Float> cost = new HashMap<>();        open.add(new RelativePoint(0, 0));        cost.put(new RelativePoint(0, 0), 0f);        while (!open.isEmpty()) {            RelativePoint current = open.poll();            AbsolutePoint currentPoint = current.toAbsolutePoint(start, unitMeters);            if (currentPoint.distance(end) <= unitMeters * 1.5f) {                LinkedList<AbsolutePoint> path = new LinkedList<>();                path.addFirst(end);                while (cameFrom.containsKey(current)) {                    current = cameFrom.get(current);                    path.addFirst(current.toAbsolutePoint(start, unitMeters));                }                path.remove(0);                return path;            }            for (RelativePoint point : directions) {                RelativePoint neighbor = new RelativePoint(current.x + point.x, current.y + point.y);                AbsolutePoint neighborPoint = neighbor.toAbsolutePoint(start, unitMeters);                if (neighborPoint.distance(start) > distanceLimit) {                    continue;                }                if (!canMoveToPoint(entity.getBody(), entity.boundingRectangle, neighborPoint)) {                    continue;                }                float newCost = cost.get(current) + heuristic(currentPoint, neighborPoint);                if (!cost.containsKey(neighbor) || newCost < cost.get(neighbor)) {                    cost.put(neighbor, newCost);                    cameFrom.put(neighbor, current);                    open.add(neighbor);                }            }        }        return null;    }    public List<AbsolutePoint> getRandomSinglePointPath(Entity entity, Random random) {        AbsolutePoint start = entity.getPosition();        List<AbsolutePoint> candidates = new ArrayList<>(directions.length);        for (RelativePoint point : directions) {            AbsolutePoint end = point.toAbsolutePoint(start, unitMeters);            if (canMoveToPoint(entity.body, entity.boundingRectangle, end)) candidates.add(end);        }        if (candidates.isEmpty()) return List.of();        return List.of(candidates.get(random.nextInt(candidates.size())));    }}